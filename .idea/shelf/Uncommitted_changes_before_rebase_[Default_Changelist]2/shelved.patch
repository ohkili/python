Index: reservation_golf_for_macmini.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\nimport chromedriver_autoinstaller\nimport time\n# from  datetime import  *\nimport pandas as pd\nimport requests\nimport json\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.common.keys import Keys\nimport random\nfrom selenium.webdriver.support.ui import WebDriverWait\n\nfrom selenium.webdriver.support import expected_conditions as EC\nfrom selenium.common.exceptions import NoSuchElementException\nfrom selenium.webdriver.common.alert import Alert\nfrom bs4 import BeautifulSoup\n\nimport schedule\nimport ssl\nimport telegram\n\n# chrome driver auto install and driver activation\ndef chromedriver_autorun():\n\n    chrome_ver = chromedriver_autoinstaller.get_chrome_version().split('.')[0]  #크롬드라이버 버전 확인\n\n    try:\n        driver = webdriver.Chrome(f'./{chrome_ver}/chromedriver.exe')\n    except:\n\n        chromedriver_autoinstaller.install(True)\n        driver = webdriver.Chrome(f'./{chrome_ver}/chromedriver.exe')\n\n    driver.implicitly_wait(10)\n    return driver\n\ndef driverAct(url, option ='macmini'):\n    os = {'macmini': 'macmini',\n          'macpro' : 'macpro',\n          'win': 'windows'}\n\n    os_option = os[option]\n    if os_option == 'macmini':\n        executable_path =  '/Users/gwon-yonghwan/PycharmProjects/chromedriver'\n        #'/Users/home/PycharmProjects/chromedriver'   # '/usr/local/bin/chromedriver'  # 크롬드라이버가 보안에 막혀서 크롬드라이버를 압축풀고 해당 폴더로 이동시켜주었다\n    elif os_option == 'macpro':\n        executable_path = '/Users/home/PycharmProjects/chromedriver'\n    elif os_option == 'windows':\n        # executable_path = \"C:\\\\Users\\ohkil\\\\PycharmProjects\\\\chromedriver_win32\\\\chromedriver.exe\"  # 크롬드라이버가 보안에 막혀서 크롬드라이버를 압축풀고 해당 폴더로 이동시켜주었다\n        executable_path = \"C:/Users\\ohkil/PycharmProjects/chromedriver_win32/chromedriver.exe\"  # 크롬드라이버가 보안에 막혀서 크롬드라이버를 압축풀고 해당 폴더로 이동시켜주었다\n\n    else:\n        print('Check your OS type')\n    driver = webdriver.Chrome(executable_path=executable_path)\n    driver.set_window_size(1400, 1000)  # (가로, 세로)음\n    driver.get(url)\n    return driver\n\n\n# REST_API_KEY and refresh_token is borrow\nREST_API_KEY ='22644bd965c28d381ea875a9dde9e2d1'\nrefresh_token = '2hZcRLD01s1Rl0qEA0BhnenFH1om0rtTNimYSgo9cuoAAAF81jvBOA'\n\n# https://kauth.kakao.com/oauth/authorize?client_id={REST API 키}&redirect_uri=https://localhost:3000&response_type=code&scope=talk_message\n# https://kauth.kakao.com/oauth/authorize?client_id=22644bd965c28d381ea875a9dde9e2d1&redirect_uri=https://localhost:3000&response_type=code&scope=talk_message\n# 카카오톡 메시지 API\n# rest api key와 refresth token을 이용하여 access token 갱신\ndef access_token_mkr(REST_API_KEY, refresh_token):\n    url = \"https://kauth.kakao.com/oauth/token\"\n\n    data = {\n        \"grant_type\": \"refresh_token\",\n        \"client_id\": REST_API_KEY,\n        \"refresh_token\": refresh_token\n    }\n    response = requests.post(url, data=data)\n    tokens2 = response.json()\n    print(tokens2)\n\n    access_token = tokens2['access_token']\n    return access_token\n\ndef kakao_message(data, access_token):\n    url = \"https://kapi.kakao.com/v2/api/talk/memo/default/send\"\n    # access_token = 'pnvTjrwWOlNoRrFHo5IEfDco_Mi9Kf7R-vC_TQorDNMAAAF8IfKFow'  # tokens['access_token']\n\n    # 사용자 토큰\n    headers = {\n        \"Authorization\": \"Bearer \" + access_token}\n\n    data = {\n        \"template_object\": json.dumps({\"object_type\": \"text\",\n                                   \"text\": str(data),\n                                       \"link\": {\n                                           \"web_url\": \"www.naver.com\"\n                                       }\n                                       })\n    }\n\n    response = requests.post(url, headers=headers, data=data)\n    print(response.status_code)\n    if response.json().get('result_code') == 0:\n        print('메시지를 성공적으로 보냈습니다.')\n    else:\n        print('메시지를 성공적으로 보내지 못했습니다. 오류메시지 : ' + str(response.json()))\n\ndef telegram_message(content='Hello world', content_type='text', description='description'):\n    telegram_token = \"5011897744:AAFvwnQrdllp09gz2Iy_XD6SONWy1-jQuNM\"\n    telegram_chat_id = 1926421781\n    bot = telegram.Bot(token=telegram_token)\n\n\n    # Bottom is telegram bot manual\n    \"\"\" \n    # text 보내기\n    bot.sendMessage(chat_id=telegram_chat_id, text='hello world')\n    # image 보내기 image url\n    photo_url = \"https://telegram.org/img/t_logo.png\"\n    bot.sendPhoto(chat_id=telegram_chat_id, photo=photo_url, caption='telegrm logo')\n    # hyperlink 보내기\n    # 미리보기 기능 off ==>  disable_web_page_preview= True\n    # []안에 문자는 제목으로 전송되고, ()안에 hyperlink 넣어주면 됨\n    bot.send_message(chat_id=telegram_chat_id, text=\"[naver 증권](https://finance.naver.com)\", parse_mode='Markdown',\n                     disable_web_page_preview=False)\n\n    # image 보내기 image file\n    # os.getcwd()\n    # glob.glob('E:\\\\python\\\\' + '*.jpg')\n    photo_file = 'E:\\\\python\\\\주행기록.jpg'\n    bot.sendPhoto(chat_id=telegram_chat_id, photo=open(photo_file, 'rb'), caption='카니발 주행기록') \n    \"\"\"\n\n    if content_type == 'text':\n        # example is 'hello world'\n        bot.sendMessage(chat_id=telegram_chat_id, text=content)\n    elif content_type == 'imgUrl':\n        # example is  \"https://telegram.org/img/t_logo.png\"\n        bot.sendPhoto(chat_id=telegram_chat_id, photo=content, caption=description)\n    elif content_type == 'imgFile':\n        # example is 'E:\\\\python\\\\주행기록.jpg'\n        bot.sendPhoto(chat_id=telegram_chat_id, photo=open(content, 'rb'), caption=description)\n    elif content_type == 'hyperlink':\n        # []안에 문자는 제목으로 전송되고, ()안에 hyperlink 넣어주면 됨\n        #  example is \"[naver 증권](https://finance.naver.com)\"\n        content_hyperlink = \"[\" + description + \"](\" + content + \")\"\n        bot.send_message(chat_id=telegram_chat_id, text=content_hyperlink, parse_mode='Markdown',\n                         disable_web_page_preview=False)\n    else:\n        print('You must choice content_type as text, imgUrl, imgFile, hyperlink')\n\n\ndef good_luck_kakao():\n      print(\"Good Luck for Test\")\n      print( time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time())))\n      access_token = access_token_mkr(REST_API_KEY,refresh_token)\n      kakao_message('message test from macmini with golf '+ str( time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time()))),access_token)\n\n\ndef good_luck():\n    print(\"Good Luck for Test\")\n    print(time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time())))\n    content_new =  'message test from macmini with golf ' + str(time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time())))\n    telegram_message(content = content_new, content_type='text', description= 'etc' )\ndef reserve_rivera(loginfo,info_date,reserve_cnt=1,reserve_type='test', multi_date = False):\n    # info_rivera = {'url': 'https://www.shinangolf.com/',\n    #                'loginPage': 'https://www.shinangolf.com/member/login',\n    #                'id': 'ohkili',\n    #                'pw': 'Sin!1203'\n    #                }\n    # loginfo = info_rivera\n    # info_date = info_date_test\n    #\n    'log information from loginfo var. '\n    url = loginfo['url']\n    loginpage = loginfo['loginPage']\n    loginID = loginfo['id']\n    loginPW = loginfo['pw']\n    'wish date & hour information from info_date var.'\n    wish_date = info_date['wish_date']\n    wish_hour = info_date['wish_hour']\n    hour_option = info_date['hour_option']\n\n    book_try_cnt = 0\n    able_ls = []\n    driver = chromedriver_autorun()\n\n    # if reserve_cnt is True ,then reservation don't stop\n    # if reserve_cnt is False ,then reservation 1 time and stop\n    # driver.close()\n    # driver.quit()\n\n    driver.get(url)\n    driver.get(loginpage)\n\n    'id for login'\n    userId = driver.find_element(By.ID, 'memberId')  # /html/body/div/div[5]/div/div/div/div[2]/div/form/div[1]/div[1]/input\n    userId.send_keys(loginID)  # 로그인 할 계정 id\n\n    'password for login'\n    userPwd = driver.find_element(By.ID, 'key')  # /html/body/div/div[5]/div/div/div/div[2]/div/form/div[1]/div[2]/input\n    userPwd.send_keys(loginPW)\n    userPwd.send_keys(Keys.ENTER)\n\n    # log in putton userPwd에 password를 엔터를 치면 되는데, 아래처럼 로그인 버튼을 누를수도 있다\n    # loginbtn = driver.find_element(By.XPATH, \"//form[@id='loginForm']/div[@class='login_btn']\")\n    # loginbtn.click()\n\n    '통합 예약/실시간예약 접속 화면'\n    # reservation = driver.find_element(By.XPATH,\"/html/body/div/div[2]/div/div[2]/div[1]/ul/li[1]/div/ul/li[1]/a\")  # /html/body/div/div[2]/div/div[2]/div[1]/ul/li[1]/div/ul/li[1]/a\n    reservation_open = driver.find_element(By.XPATH, \"/html/body/div/div[2]/div/div[2]/div[1]/ul/li[1]/div/ul/li[1]/a\")\n    driver.execute_script(\"arguments[0].click();\", reservation_open)\n    # 아래 블럭 처리한 내용은 element에서 click을 하고 시행되지 않으면 execute_script를 쓰라는 문구인데 시간을 아끼기 위해 바로 excecute_sript를 사용하였다.\n    #  \"\"\"   try:\n    #         print(\"Element is visible? \" + str(reservation_open.is_displayed()))  # elemnet visible check\n    #         reservation_open.click()\n    #         # 에러메시지가 아래와 같이 나오면 엘리먼트가 보이지 않은것이다.\n    #         # \" selenium.common.exceptions.ElementNotInteractableException: Message: element not interactable   (Session info: chrome=94.0.4606.61) \"\n    #\n    #         print(\"Element is visible? \" + str(reservation_open.is_displayed())) # elemnet visible check\n    #         except:\n    #\n    #              # 그러면 아래와 같이 명령을 쓰면 해결이 된다.\n    #             driver.execute_script(\"arguments[0].click();\",reservation_open)\n    # \"\"\"\n\n\n    # driver.close()\n    # 실시간 예약\n\n    \"\"\" <div id='container'>\n           <div id='content'>\n               <div class ='board_info_wrap'>\n                  <div class = 'inner'>\n                      < div class = 'page_tap_wrap'>  # 신안 계열 골프장 리스트\n                      < div class = 'month_wrap'> #달력\n                       < button type ='button' class= 'prev'> 지난달 버튼\n                       < span class ='year'>   올해 년도\n                       < span class = 'month'> 이번 달\n                       < button type = 'button' class 'next'> 다음달 버튼\n                       < div class = 'reservation_table calender_table> 예약 날짜 목록\n                         <table>\n                          <tbody> 이아래에 날짜별로 목록이 존재\n                           <tr> tr이 주간 묶음이고 하위에 <td>가 날짜를 뜻한다\n                            <td> 공란이면 해당 월에 날이 없는것을 말함(예약 가능일이 아니고 달력 기준 날짜)\n                              < div class ='day'>1 </div>  날짜\n                              < div class ='white'> 이면 예약 가능한 날이 없다는 것이다\n                              or \n                              <div class ='day'>12 </div> 예약이 가능한 경우는\n                              <a class='open' id='20211012'> 1팀/<a>  날짜와 예약 가능 팀수를 알수 있다. 클릭하면 상세 날짜가 나온다 \n                        <div id ='reservationSelect'> 예약 상세 page 위에 날짜를 선택해야 상세 page가 열림\n                          <div class ='date_wrap' > 해당 날짜\n                            < div class = 'reservation_table time_table>\n                               <table>\n                                 <thread> \n                                    <tr> 예약 상세화면의 컬럼 정보, [코스, 시간, 그린피, 예약]\n                                 <tbody> \n                                     <tr> 예약 상세정보 이게 중요한 예약 가능 정보임, \n                                        <th rowspan =2> LAKES </th>  코스 정보 및 해당 코스(LAKES) 에 몇개 예약(rowspn)이 가능한지 숫자 나옴\n                                        <td> 18:52 </td> 시간\n                                        <td> 130,000 </td> 금액\n                                        <td> \n                                           <button conclick> 예약 선택 버튼 \"\"\"\n    date_count = len(wish_date)\n    for dt in wish_date:\n\n        if date_count >0 :\n\n            try:\n                '원하는 일정 목록에서 년 월 일 정보 추'\n                wish_year = dt[:4]\n                wish_month = dt[4:6]\n                wish_day = dt[6:8]\n\n                '예약 화면의 달력으로 이동'\n                calendar = driver.find_element(By.XPATH, \"//div[@class='reservation_table calendar_table']/table/tbody\")\n\n                if reserve_type   ==  'real':\n                    pass\n                elif reserve_type == 'test':\n                    status_year  = driver.find_element(By.XPATH, \"//div[@class='month_wrap']/span[@class ='year']\").text[:4]\n                    status_month = driver.find_element(By.XPATH, \"//div[@class='month_wrap']/span[@class ='month']\").text[:2]\n                    if wish_year > status_year or wish_month > status_month :\n                        driver.find_element(By.XPATH, \"//div[@class='month_wrap]/button[@class='next']\").click()\n                    else:\n                        pass\n                    calendar_week = driver.find_elements(By.XPATH,\n                                                         \"//div[@class='reservation_table calendar_table']/table/tbody/tr\")\n                    for i in range(len(calendar_week[0].find_elements(By.XPATH, \"//td\"))):\n                        '예약 가능한 날짜 추출'\n                        s = (calendar_week[0].find_elements(By.XPATH, \"//td\")[i].text)\n                        if s.find('\\n')>0:\n                            s = s.split('\\n')[0]\n                            able_date = wish_year + wish_month + s.zfill(2)\n                            able_ls.append(able_date)\n                        else:\n                            pass\n                        '예약 가능일이 원하는 날과 같으면 예약 시도 횟수를 +1 한다'\n                        if s  == str(int(wish_day)):\n                            book_try_cnt += 1\n                        else:\n                            pass\n                        # print(i, s, able_ls, book_try_cnt)\n\n\n                else:\n                    pass\n\n            except:\n                print('macro fail : date simple check')\n                # access_token = access_token_mkr(REST_API_KEY, refresh_token)\n                # kakao_message('rivera macro fail  : date simple check  \\n' + str( time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time()))) , access_token)\n\n                telegram_message(content='rivera macro fail  : date simple check  \\n' + str( time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time())))\n                                 , content_type='text', description='description')\n\n            try:\n                if reserve_type == 'real':\n                    pass\n\n                elif reserve_type == 'test' and len(able_ls) >0 :\n                    '예약 타입이 test 이면서 예약 가능일이 있으면 예약 가능일 첫 날을 dt 변수에 넣는다.'\n                    dt = able_ls[0]\n                elif reserve_type == 'test' and len(able_ls) ==0 and  book_try_cnt == len(wish_date):\n                    '예약 타입이 test 이면서 예약 가능일이 없고 예약 시도횟수와 원하는 날 수가 같다면 반복문에서 빠져나'\n                    continue\n                else:\n                    print('Check book_try_cnt')\n                    continue\n\n\n                date_selected_1 = \"//tr/td/a[@class='open'  and @id =\" + \"'\" + dt + \"']\"\n                date_selected_2 = \"//tr/td/a[@class='open active'  and @id =\" + \"'\" + dt + \"']\"\n                # temp_date = calendar.find_element(By.XPATH, \"//tr/td/a[@class='open'  and @id ='20211028']\")\n                # temp_date = calendar.find_element(By.XPATH, \"//tr/td/a[@class='open active'  and @id ='20211028']\")\n                # calendar.find_element(By.XPATH, date_selected).text 에 예약이 가능하면 팀수가 나옴 없으면 예약 불가능하므로 예약 시도 cancel\n\n                if calendar.find_element(By.XPATH, date_selected_1).text.find('팀') >= 0:\n                    calendar_selected = calendar.find_element(By.XPATH, date_selected_1)\n                elif calendar.find_element(By.XPATH, date_selected_2).text.find('팀') >= 0:\n                    calendar_selected = calendar.find_element(By.XPATH, date_selected_2)\n                elif calendar.find_element(By.XPATH, date_selected_1).text.find('팀') == -1 and calendar.find_element(By.XPATH, date_selected_2).text.find('팀') == -1:   # 예약일이 없으면 바로 빠져 나와서 처리 속도를 높여줌\n                    print('There is no book', dt)\n\n                    break\n\n                else :\n                    print('Check Calendar')\n\n\n\n\n                calendar_selected.click()     # 원하는 날짜에 해당하는 달력 check\n                # calendar.find_element(By.XPATH, date_selected).text\n\n                reservation_time = driver.find_element(By.XPATH, \"//div[@class = 'reservation_table time_table']\")\n                reservation_time_list = reservation_time.find_elements(By.XPATH, \"//table/tbody/tr/td/button\")\n\n\n                # s = reservation_time_list[0].get_attribute('onclick')\n                # s = s.replace('showConfirm','').replace('(','').replace(')','').replace(\"'\",'').split(',')\n\n                # time table을 list로 만들자\n                timeTable = pd.DataFrame()\n                timeTable_columns = ['fulldate', 'day', 'hour', 'course_type', 'cousrse_name', 'price', 'unknown1',\n                                     'unknown2', 'unknown3']\n\n                for i in range(len(reservation_time_list)):\n                    s = reservation_time_list[i].get_attribute('onclick')\n                    s = s.replace('showConfirm', '').replace('(', '').replace(')', '').replace(\"'\", '').split(',')\n                    s = pd.DataFrame(data=[s])\n                    timeTable = timeTable.append(s)\n                    print(i, s)\n\n                timeTable.columns = timeTable_columns\n                timeTable.reset_index(drop=True, inplace=True)\n\n                '원하는 시간대 골라내기'\n                timeTable_filterd = pd.DataFrame()\n                for h in wish_hour:\n                    first_time = h.split('~')[0]\n                    end_time = h.split('~')[1]\n                    mask1 = (timeTable['hour'].str[0:2] >= first_time) & (\n                                timeTable['hour'].str[0:2] < end_time)  # 시간대 filter\n\n                    timeTable_sorted = timeTable.loc[mask1, :].sort_values('hour')\n                    timeTable_filterd = pd.concat([timeTable_filterd, timeTable_sorted])\n\n                timeTable_filterd.reset_index(inplace=True)\n                while(reserve_cnt > 0):\n\n                    if hour_option == 'first':\n                        index_no = timeTable_filterd['index'].iloc[0]\n                    elif hour_option == 'mid':\n                        index_no = timeTable_filterd['index'].iloc[round(len(timeTable_sorted) / 2)]\n                    elif hour_option == 'last':\n                        index_no = timeTable_filterd['index'].iloc[-1]\n\n                    idx = timeTable_filterd[timeTable_filterd['index'] == index_no].index\n                    timeTable_filterd = timeTable_filterd.drop(idx)\n\n                    # 골라낸 시간에 예약 버튼 누르기\n\n                    # reservation_time_list[index_no].get_attribute('onclick')\n                    # reservation_time_list[index_no].click()\n                    #\n                    # reservation_time_list[index_no].get_attribute('onclick')\n                    driver.execute_script(\"arguments[0].click();\", reservation_time_list[index_no])\n\n                    # 예약 확인 pop up\n\n                    popup_text = driver.find_element(By.XPATH,\n                                                     \"//div[@id='confirmModal']/div[@class='modal_content']/div[@class='confirm_modal']\").text\n                    print(popup_text)\n                    reserve_text = driver.find_element(By.XPATH,\n                                                       \"//div[@id='confirmModal']/div[@class='modal_content']/div[@class='confirm_modal']/div[@class='form_btns']/button\").text\n                    print(reserve_text)\n\n                    if reserve_type == 'real':\n                        driver.find_element(By.XPATH,\n                                        \"//div[@id='confirmModal']/div[@class='modal_content']/div[@class='confirm_modal']/div[@class='form_btns']/button\").click()\n                        # 이렇게 하면 바로 예약 됨\n                        popup_text = '[예약 완료, macro 정상 동작]\\n' +  + popup_text\n                        # kakao_message(popup_text, access_token)\n\n                        telegram_message(content=popup_text , content_type='text', description='description')\n\n                    elif   reserve_type == 'test' and reserve_text =='예약하기':\n                        # 카카오 문자 보내기\n                        driver.find_element(By.XPATH,\n                                            \"//div[@id='confirmModal']/div[@class='modal_content']/div[@class='confirm_modal']/div[@class='form_btns']/a\").click()\n                        access_token = access_token_mkr(REST_API_KEY, refresh_token)\n                        popup_text = '[예약 macro 정상 동작]\\n' + '[예약이 된것은 아님]\\n'+ popup_text\n                        # kakao_message(popup_text, access_token)\n                        telegram_message(content=popup_text, content_type='text', description='description')\n\n                    else:\n                        print('Check reserve count')\n                    reserve_cnt -= 1  # 예약 건수를 1개 줄임\n                    if multi_date == True:\n                        date_count -= 1\n                    elif multi_date == False:\n                        date_count = 0\n                    else:\n                        print('Check multidate option')\n\n\n            except:\n                print('macro fail:  targetting reserve')\n                # access_token = access_token_mkr(REST_API_KEY, refresh_token)\n                # kakao_message('rivera macro fail:  targetting reserve  \\n' + str(time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time()))), access_token)\n                telegram_message(content='rivera macro fail:  targetting reserve  \\n' + str(time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time()))),\n                                 content_type='text', description='description')\n\n        elif date_count == 0:\n            break\n        else :\n            print('Check date_count')\n    if book_try_cnt == len(wish_date):\n        # access_token = access_token_mkr(REST_API_KEY, refresh_token)\n        # kakao_message('There is no able day to book \\n' + str( time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time()))), access_token)\n        telegram_message(content='There is no able day to book \\n' + str( time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time()))),\n                         content_type='text', description='description')\n    else:\n        print('Check book_try_cnt')\n\n    print('book_try_cnt',book_try_cnt)\n    print('wish_date',wish_date)\n    driver.close()\ndef reserve_rivera_macmini(loginfo,info_date,reserve_try_cnt=9,reserve_type='test', multi_date = False,osopt='macmini'):\n    # driver.close()\n    # loginfo = info_rivera\n    # info_date = info_date_test\n    'reserve_try_cnt means n times trying for reservation, when website clock is not sync with code'\n\n    url = loginfo['url']\n    loginpage = loginfo['loginPage']\n    loginID = loginfo['id']\n    loginPW = loginfo['pw']\n\n    wish_date = info_date['wish_date']\n    wish_hour = info_date['wish_hour']\n    hour_option = info_date['hour_option']\n\n    book_try_cnt = 0\n    reserve_succees_cnt = 0\n    reserve_need_cnt = len(wish_date) * len(wish_hour)\n    date_count = len(wish_date)\n\n    if reserve_type == 'real':\n        pass\n    elif reserve_type == 'test':\n        reserve_try_cnt = 1\n    else:\n        reserve_try_cnt =0\n        telegram_message(content='Please, check your reserve_type', content_type='text', description='description')\n\n    able_ls = []\n    try:\n        driver = driverAct(url,osopt)\n    except:\n        telegram_message('Please check your chrom driver version or path.')\n    driver.get(loginpage)\n    # if reserve_cnt is True ,then reservation don't stop\n    # if reserve_cnt is False ,then reservation 1 time and stop\n    # driver.close()\n    # driver.quit()\n\n\n\n    # id\n    userId = driver.find_element(By.ID, 'memberId')  # /html/body/div/div[5]/div/div/div/div[2]/div/form/div[1]/div[1]/input\n    userId.send_keys(loginID)  # 로그인 할 계정 id\n\n    # password\n    userPwd = driver.find_element(By.ID, 'key')  # /html/body/div/div[5]/div/div/div/div[2]/div/form/div[1]/div[2]/input\n    userPwd.send_keys(loginPW)\n    userPwd.send_keys(Keys.ENTER)\n\n    # log in putton userPwd에 password를 엔터를 치면 되는데, 아래처럼 로그인 버튼을 누를수도 있다\n    # loginbtn = driver.find_element(By.XPATH, \"//form[@id='loginForm']/div[@class='login_btn']\")\n    # loginbtn.click()\n\n    # 통합 예약/실시간예약\n    # reservation = driver.find_element(By.XPATH,\"/html/body/div/div[2]/div/div[2]/div[1]/ul/li[1]/div/ul/li[1]/a\")  # /html/body/div/div[2]/div/div[2]/div[1]/ul/li[1]/div/ul/li[1]/a\n    reservation_open = driver.find_element(By.XPATH, \"/html/body/div/div[2]/div/div[2]/div[1]/ul/li[1]/div/ul/li[1]/a\")\n    driver.execute_script(\"arguments[0].click();\", reservation_open)\n    # 아래 블럭 처리한 내용은 element에서 click을 하고 시행되지 않으면 execute_script를 쓰라는 문구인데 시간을 아끼기 위해 바로 excecute_sript를 사용하였다.\n    #  \"\"\"   try:\n    #         print(\"Element is visible? \" + str(reservation_open.is_displayed()))  # elemnet visible check\n    #         reservation_open.click()\n    #         # 에러메시지가 아래와 같이 나오면 엘리먼트가 보이지 않은것이다.\n    #         # \" selenium.common.exceptions.ElementNotInteractableException: Message: element not interactable   (Session info: chrome=94.0.4606.61) \"\n    #\n    #         print(\"Element is visible? \" + str(reservation_open.is_displayed())) # elemnet visible check\n    #         except:\n    #\n    #              # 그러면 아래와 같이 명령을 쓰면 해결이 된다.\n    #             driver.execute_script(\"arguments[0].click();\",reservation_open)\n    # \"\"\"\n\n\n    # driver.close()\n    # 실시간 예약\n\n    \"\"\" <div id='container'>\n           <div id='content'>\n               <div class ='board_info_wrap'>\n                  <div class = 'inner'>\n                      < div class = 'page_tap_wrap'>  # 신안 계열 골프장 리스트\n                      < div class = 'month_wrap'> #달력\n                       < button type ='button' class= 'prev'> 지난달 버튼\n                       < span class ='year'>   올해 년도\n                       < span class = 'month'> 이번 달\n                       < button type = 'button' class 'next'> 다음달 버튼\n                       < div class = 'reservation_table calender_table> 예약 날짜 목록\n                         <table>\n                          <tbody> 이아래에 날짜별로 목록이 존재\n                           <tr> tr이 주간 묶음이고 하위에 <td>가 날짜를 뜻한다\n                            <td> 공란이면 해당 월에 날이 없는것을 말함(예약 가능일이 아니고 달력 기준 날짜)\n                              < div class ='day'>1 </div>  날짜\n                              < div class ='white'> 이면 예약 가능한 날이 없다는 것이다\n                              or \n                              <div class ='day'>12 </div> 예약이 가능한 경우는\n                              <a class='open' id='20211012'> 1팀/<a>  날짜와 예약 가능 팀수를 알수 있다. 클릭하면 상세 날짜가 나온다 \n                        <div id ='reservationSelect'> 예약 상세 page 위에 날짜를 선택해야 상세 page가 열림\n                          <div class ='date_wrap' > 해당 날짜\n                            < div class = 'reservation_table time_table>\n                               <table>\n                                 <thread> \n                                    <tr> 예약 상세화면의 컬럼 정보, [코스, 시간, 그린피, 예약]\n                                 <tbody> \n                                     <tr> 예약 상세정보 이게 중요한 예약 가능 정보임, \n                                        <th rowspan =2> LAKES </th>  코스 정보 및 해당 코스(LAKES) 에 몇개 예약(rowspn)이 가능한지 숫자 나옴\n                                        <td> 18:52 </td> 시간\n                                        <td> 130,000 </td> 금액\n                                        <td> \n                                           <button conclick> 예약 선택 버튼 \"\"\"\n\n\n    while(reserve_need_cnt > 0 and reserve_try_cnt > 0 ):\n        for dt in wish_date:\n            # dt = wish_date[0]\n            if date_count > 0:\n\n                try:\n                    wish_year  = dt[:4]\n                    wish_month = dt[4:6]\n                    wish_day   = dt[6:8]\n\n                    calendar = driver.find_element(By.XPATH, \"//div[@class='reservation_table calendar_table']/table/tbody\")\n\n                    if reserve_type   ==  'real':\n                        pass\n                    elif reserve_type == 'test':\n                        status_year  = driver.find_element(By.XPATH, \"//div[@class='month_wrap']/span[@class ='year']\").text[:4]\n                        status_month = driver.find_element(By.XPATH, \"//div[@class='month_wrap']/span[@class ='month']\").text[:2]\n                        if wish_year > status_year or wish_month > status_month :\n                            driver.find_element(By.XPATH, \"//div[@class='month_wrap']/button[@class='next']\").click()\n                        else:\n                            pass\n                        calendar_week = driver.find_elements(By.XPATH,\n                                                           \"//div[@class='reservation_table calendar_table']/table/tbody/tr\")\n\n\n                        for i in range(len(calendar_week[0].find_elements(By.XPATH, \"//td\"))):\n\n                            s = (calendar_week[0].find_elements(By.XPATH, \"//td\")[i].text)\n                            if s.find('\\n')>0:\n                                s = s.split('\\n')[0]\n                                able_date = wish_year + wish_month + s.zfill(2)\n                                able_ls.append(able_date)\n                            else:\n                                pass\n                            if s  == str(int(wish_day)):\n                                book_try_cnt += 1\n                            else:\n                                pass\n                            # print(i, s, able_ls, book_try_cnt)\n\n\n                    else:\n                        pass\n\n                except:\n                    print('macro fail : date simple check')\n                    # access_token = access_token_mkr(REST_API_KEY, refresh_token)\n                    # kakao_message('rivera macro fail  : date simple check  \\n' + str( time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time()))) , access_token)\n                    telegram_message(content='rivera macro fail  : date simple check  \\n' + str( time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time()))),\n                                     content_type='text', description='description')\n\n\n                try:\n                    if reserve_type == 'real':\n                        pass\n                    elif reserve_type == 'test' and len(able_ls) >0 :\n                        dt = able_ls[0]\n\n                    elif reserve_type == 'test' and len(able_ls) ==0 and  book_try_cnt == len(wish_date):\n\n                        pass\n                    else:\n                        print('Check book_try_cnt')\n\n\n\n                    date_selected_1 = \"//tr/td/a[@class='open'  and @id =\" + \"'\" + dt + \"']\"\n                    date_selected_2 = \"//tr/td/a[@class='open active'  and @id =\" + \"'\" + dt + \"']\"\n                    # temp_date = calendar.find_element(By.XPATH, \"//tr/td/a[@class='open'  and @id ='20211028']\")\n                    # temp_date = calendar.find_element(By.XPATH, \"//tr/td/a[@class='open active'  and @id ='20211028']\")\n                    # calendar.find_element(By.XPATH, date_selected).text 에 예약이 가능하면 팀수가 나옴 없으면 예약 불가능하므로 예약 시도 cancel\n                    try:\n                        date_check1 = calendar.find_element(By.XPATH, date_selected_1).text.find('팀')\n                    except:\n                        date_check1 = -1\n\n                    try:\n                        date_check2 =  calendar.find_element(By.XPATH, date_selected_2).text.find('팀')\n                    except:\n                        date_check2 = -1\n\n                    if date_check1 >= 0:\n                        calendar_selected = calendar.find_element(By.XPATH, date_selected_1)\n                    elif date_check2 >= 0:\n                        calendar_selected = calendar.find_element(By.XPATH, date_selected_2)\n                    elif date_check1 == -1 and date_check2 == -1:   # 예약일이 없으면 바로 빠져 나와서 처리 속도를 높여줌\n                        print('There is no book', dt)\n\n                    else :\n                        print('Check Calendar')\n\n\n\n\n                     # calendar_selected.click()     # 원하는 날짜에 해당하는 달력 check\n                    driver.execute_script(\"arguments[0].click();\", calendar_selected)\n                    # calendar.find_element(By.XPATH, date_selected).text\n                    reservation_time = WebDriverWait(driver, 30).until(\n                        EC.presence_of_all_elements_located((By.XPATH, \"//div[@class = 'reservation_table time_table']\"))\n                    )\n                    # reservation_time = driver.find_element(By.XPATH, \"//div[@class = 'reservation_table time_table']\")\n                    reservation_time_list = WebDriverWait(driver, 30).until(\n                        EC.presence_of_all_elements_located((By.XPATH, \"//table/tbody/tr/td/button\"))\n                    )\n                    # reservation_time_list = reservation_time.find_elements(By.XPATH, \"//table/tbody/tr/td/button\")\n\n\n                    # s = reservation_time_list[0].get_attribute('onclick')\n                    # s = s.replace('showConfirm','').replace('(','').replace(')','').replace(\"'\",'').split(',')\n\n                    # time table을 list로 만들자\n                    timeTable = pd.DataFrame()\n                    timeTable_columns = ['fulldate', 'day', 'hour', 'course_type', 'cousrse_name', 'price', 'unknown1',\n                                         'unknown2', 'unknown3']\n\n                    for i in range(len(reservation_time_list)):\n                        s = reservation_time_list[i].get_attribute('onclick')\n                        s = s.replace('showConfirm', '').replace('(', '').replace(')', '').replace(\"'\", '').split(',')\n                        s = pd.DataFrame(data=[s])\n                        timeTable = timeTable.append(s)\n                        print(i, s)\n\n                    timeTable.columns = timeTable_columns\n                    timeTable.reset_index(drop=True, inplace=True)\n\n                    # 원하는 시간대 골라내기\n                    timeTable_filterd = pd.DataFrame()\n                    for h in wish_hour:\n                        first_time = h.split('~')[0]\n                        end_time = h.split('~')[1]\n                        mask1 = (timeTable['hour'].str[0:2] >= first_time) & (\n                                    timeTable['hour'].str[0:2] < end_time)  # 시간대 filter\n\n                        timeTable_sorted = timeTable.loc[mask1, :].sort_values('hour')\n                        timeTable_filterd = pd.concat([timeTable_filterd, timeTable_sorted])\n\n                    timeTable_filterd.reset_index(inplace=True)\n                except:\n                    print('macro fail:  making reserve table')\n                    # access_token = access_token_mkr(REST_API_KEY, refresh_token)\n                    # kakao_message('rivera macro fail:  making reserve table \\n' + str(\n                    #     time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time()))), access_token)\n                    telegram_message(content='rivera macro fail:  making reserve table \\n' + str(time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time()))),\n                                     content_type='text', description='description')\n                try:\n\n                    while(reserve_need_cnt > 0):\n\n                        if hour_option == 'first':\n                            index_no = timeTable_filterd['index'].iloc[0]\n                        elif hour_option == 'mid':\n                            index_no = timeTable_filterd['index'].iloc[round(len(timeTable_sorted) / 2)]\n                        elif hour_option == 'last':\n                            index_no = timeTable_filterd['index'].iloc[-1]\n\n                        idx = timeTable_filterd[timeTable_filterd['index']== index_no].index\n                        timeTable_filterd = timeTable_filterd.drop(idx)\n\n                        # 골라낸 시간에 예약 버튼 누르기\n\n                        # reservation_time_list[index_no].get_attribute('onclick')\n                        # reservation_time_list[index_no].click()\n                        #\n                        # reservation_time_list[index_no].get_attribute('onclick')\n                        driver.execute_script(\"arguments[0].click();\", reservation_time_list[index_no])\n\n                        # 예약 확인 pop up\n\n                        popup_text = driver.find_element(By.XPATH,\n                                                         \"//div[@id='confirmModal']/div[@class='modal_content']/div[@class='confirm_modal']\").text\n                        print(popup_text)\n                        reserve_button = driver.find_element(By.XPATH,\n                                            \"//div[@id='confirmModal']/div[@class='modal_content']/div[@class='confirm_modal']/div[@class='form_btns']/button\")\n                        reserve_text = reserve_button.text\n                        print(reserve_text)\n                        reserve_close_button =  driver.find_element(By.XPATH, \"//div[@id='confirmModal']/div[@class='modal_content']/div[@class='confirm_modal']/div[@class='form_btns']/a\")\n\n                        if reserve_type == 'real':\n                            reserve_button.click()\n                            # 이렇게 하면 바로 예약 됨\n                            # popup_text = '[예약 완료, macro 정상 동작]\\n' +  + popup_text\n                            # kakao_message(popup_text, access_token)\n                            reserve_succees_cnt += 1\n                            reserve_need_cnt    -= 1\n                            telegram_message(content=popup_text,content_type='text', description='description')\n\n                        elif   reserve_type == 'test' and reserve_text =='예약하기':\n                            # 카카오 문자 보내기\n                            reserve_close_button.click()\n                            # access_token = access_token_mkr(REST_API_KEY, refresh_token)\n                            popup_text = '[예약 macro 정상 동작]\\n' + '[예약이 된것은 아님]\\n'+ popup_text\n                            # kakao_message(popup_text, access_token)\n                            reserve_need_cnt =0\n                            reserve_try_cnt = 0\n                            telegram_message(content=popup_text, content_type='text', description='description')\n\n                        else:\n                            print('Check reserve count')\n                        # reserve_cnt -= 1  # 예약 건수를 1개 줄임\n                        if multi_date == True:\n                            date_count -= 1\n                        elif multi_date == False:\n                            date_count = 0\n                        else:\n                            print('Check multidate option')\n\n\n                except:\n                    print('macro fail:  targetting reserve while sentence! ')\n                    # access_token = access_token_mkr(REST_API_KEY, refresh_token)\n                    # kakao_message('rivera macro fail:  targetting reserve while sentence!  \\n' + str(time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time()))), access_token)\n                    telegram_message(content='rivera macro fail:  targetting reserve while sentence!  \\n' + str(time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time()))),\n                                     content_type='text', description='description')\n\n            elif date_count == 0:\n                pass\n            else :\n                print('Check date_count')\n        if book_try_cnt == len(wish_date):\n            # access_token = access_token_mkr(REST_API_KEY, refresh_token)\n            # kakao_message('There is no able day to book \\n' + str( time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time()))), access_token)\n            telegram_message(content='There is no able day to book \\n' + str( time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time()))),\n                             content_type='text', description='description')\n        else:\n            print('Check book_try_cnt')\n        if reserve_try_cnt >0 :\n            reserve_try_cnt -= 1\n        else :\n            pass\n        print('book_try_cnt',book_try_cnt)\n        print('wish_date',wish_date)\n        driver.close()\n\ndef info_date_test():\n\n    #  wish_date 자동 생성\n    time_ls = []\n    tm = time.time()\n    for t in range(30):\n        d = tm + t * 86400\n        temp_tm = time.localtime(d)\n        string = time.strftime('%Y%m%d', temp_tm)\n        time_ls.append(string)\n\n    info_date_test = {'wish_date': time_ls,\n                      'wish_hour': ['05~23'],\n                      'hour_option': 'first'\n                      }\n    return info_date_test\n# a = info_date_test()\n# time_ls =[]\n# tm = time.time()\n# for t in range(2):\n#     d = tm + t* 86400\n#     temp_tm = time.localtime(d)\n#     string = time.strftime('%Y%m%d', temp_tm)\n#     time_ls.append(string)\n# info_date_test = {'wish_date': time_ls,\n#                 'wish_hour': ['05~23'],\n#                 'hour_option': 'first'   }\n\n# info_date_test = {'wish_date': ['20211016','20211017'],\n#                  'wish_hour': ['05~23'],\n#                  'hour_option': 'first'\n#                  }\n\n\n# 날짜 계산 연습\n# tm = time.localtime(1575142526.500323)\n# string = time.strftime('%Y-%m-%d %I:%M:%S %p', tm)\n# print(string)\n# t = time.time() 오늘 날짜\n# t = time.localtime(t)\n# t1 = t + 86400*100 100일 후 연산\n# t1 = time.localtime(t1)\n# string = time.strftime('%Y%m%d', t1)\n# print(string)\n\n\n\ninfo_rivera = {'url': 'https://www.shinangolf.com/',\n               'loginPage': 'https://www.shinangolf.com/member/login',\n               'id': 'ohkili',\n               'pw': 'Sin!1203'\n\n               }\n\n# 날짜 고르기\ninfo_date = {'wish_date': ['20211023', '20211028'],\n           'wish_hour': ['14~16', '18~19'],\n           'hour_option': 'first'\n           }\ngood_luck()\n# reserve_rivera_macmini(info_rivera, info_date_test(), reserve_cnt=1, reserve_type='test', multi_date=False)\n# test\n# reserve_rivera(info_rivera, info_date_test(), reserve_cnt=1, reserve_type='test', multi_date=False)\n\n# Every day at 12am or 00:00 time bedtime() is called.\nschedule.every().day.at(\"19:30\").do(good_luck)\nschedule.every().day.at(\"07:30\").do(good_luck)\n# str(random.randrange(9,14)).zfill(2)\nschedule.every().day.at(\"16:15\").do(lambda:  reserve_rivera_macmini(info_rivera,info_date_test(),reserve_try_cnt=1,reserve_type='test', multi_date = False,osopt='macmini') )\nwhile True:\n\n\t# Checks whether a scheduled task\n\t# is pending to run or not\n\tschedule.run_pending()\n\n\ttime.sleep(1)\n\n\n# # test  part\n# # 1. 주요 골프장 class 만들기\n# #    0) 주요 골프장 리스트 마에스트로, 리베라,소노펠리체,  리베라(10/11 완료)\n# #    1) log in id/pw , (10/11)\n# #    2) 예약 날짜 시간 선택 조건으로 날짜대, 시간 대  고를수 있어야 하고, 시간대를 고르면 가능한 시간중  몇번째를 고를지 옵션 필요 (10/11 처음 중간 끝 중 고르게 하였음)\n# #    3)각 골프장 예약 오프되는 시간대 db로 저장 및 관리 (진행 예정)\n# # 2. 알림 메세지\n# #    1) 취소 가능일 전 미리 취소 여부 알람 메세지\n# #    2) 동반자에게 미리 알리기\n# # 3. 양도 기능\n# #    1) 예약 시간 양도 관련 내가 취소 즉시 다른 사람이 예약 가능하도록 변경 기능\n# #\n#\n# info_rivera = {'url': 'https://www.shinangolf.com/',\n#                'loginPage': 'https://www.shinangolf.com/member/login',\n#                'id': 'ohkili',\n#                'pw': 'Sin!1203'\n#                }\n#\n# # 날짜 고르기\n# info_date = {'wish_date': ['20211023', '20211028'],\n#              'wish_hour': ['14~16', '18~19'],\n#              'hour_option': 'first'\n#              }\n#\n# # wish_date = ['20211015','20211021','20211028']\n# # wish_hour = ['15~19']\n# # hour_option = 'first'  # ['first, mid, last']\n# # 골프장 고르기\n# loginfo = info_rivera\n#\n# url = loginfo['url']\n# loginpage = loginfo['loginPage']\n# loginID = loginfo['id']\n# loginPW = loginfo['pw']\n#\n# driver = chromedriver_autorun()\n# # driver.close()\n# # driver.quit()\n#\n# driver.get(url)\n# driver.get(loginpage)\n#\n# # id\n# userId = driver.find_element(By.ID, 'memberId')  # /html/body/div/div[5]/div/div/div/div[2]/div/form/div[1]/div[1]/input\n# userId.send_keys(loginID)  # 로그인 할 계정 id\n#\n# # password\n# userPwd = driver.find_element(By.ID, 'key')  # /html/body/div/div[5]/div/div/div/div[2]/div/form/div[1]/div[2]/input\n# userPwd.send_keys(loginPW)\n# userPwd.send_keys(Keys.ENTER)\n#\n# # log in putton userPwd에 password를 엔터를 치면 되는데, 아래처럼 로그인 버튼을 누를수도 있다\n# # loginbtn = driver.find_element(By.XPATH, \"//form[@id='loginForm']/div[@class='login_btn']\")\n# # loginbtn.click()\n#\n# # 통합 예약/실시간예약\n# # reservation = driver.find_element(By.XPATH,\"/html/body/div/div[2]/div/div[2]/div[1]/ul/li[1]/div/ul/li[1]/a\")  # /html/body/div/div[2]/div/div[2]/div[1]/ul/li[1]/div/ul/li[1]/a\n# reservation_open = driver.find_element(By.XPATH, \"/html/body/div/div[2]/div/div[2]/div[1]/ul/li[1]/div/ul/li[1]/a\")\n# driver.execute_script(\"arguments[0].click();\", reservation_open)\n# # 아래 블럭 처리한 내용은 element에서 click을 하고 시행되지 않으면 execute_script를 쓰라는 문구인데 시간을 아끼기 위해 바로 excecute_sript를 사용하였다.\n# #  \"\"\"   try:\n# #         print(\"Element is visible? \" + str(reservation_open.is_displayed()))  # elemnet visible check\n# #         reservation_open.click()\n# #         # 에러메시지가 아래와 같이 나오면 엘리먼트가 보이지 않은것이다.\n# #         # \" selenium.common.exceptions.ElementNotInteractableException: Message: element not interactable   (Session info: chrome=94.0.4606.61) \"\n# #\n# #         print(\"Element is visible? \" + str(reservation_open.is_displayed())) # elemnet visible check\n# #         except:\n# #\n# #              # 그러면 아래와 같이 명령을 쓰면 해결이 된다.\n# #             driver.execute_script(\"arguments[0].click();\",reservation_open)\n# # \"\"\"\n#\n#\n# # driver.close()\n# # 실시간 예약\n#\n# \"\"\" <div id='container'>\n#        <div id='content'>\n#            <div class ='board_info_wrap'>\n#               <div class = 'inner'>\n#                   < div class = 'page_tap_wrap'>  # 신안 계열 골프장 리스트\n#                   < div class = 'month_wrap'> #달력\n#                    < button type ='button' class= 'prev'> 지난달 버튼\n#                    < span class ='year'>   올해 년도\n#                    < span class = 'month'> 이번 달\n#                    < button type = 'button' class 'next'> 다음달 버튼\n#                    < div class = 'reservation_table calender_table> 예약 날짜 목록\n#                      <table>\n#                       <tbody> 이아래에 날짜별로 목록이 존재\n#                        <tr> tr이 주간 묶음이고 하위에 <td>가 날짜를 뜻한다\n#                         <td> 공란이면 해당 월에 날이 없는것을 말함(예약 가능일이 아니고 달력 기준 날짜)\n#                           < div class ='day'>1 </div>  날짜\n#                           < div class ='white'> 이면 예약 가능한 날이 없다는 것이다\n#                           or\n#                           <div class ='day'>12 </div> 예약이 가능한 경우는\n#                           <a class='open' id='20211012'> 1팀/<a>  날짜와 예약 가능 팀수를 알수 있다. 클릭하면 상세 날짜가 나온다\n#                     <div id ='reservationSelect'> 예약 상세 page 위에 날짜를 선택해야 상세 page가 열림\n#                       <div class ='date_wrap' > 해당 날짜\n#                         < div class = 'reservation_table time_table>\n#                            <table>\n#                              <thread>\n#                                 <tr> 예약 상세화면의 컬럼 정보, [코스, 시간, 그린피, 예약]\n#                              <tbody>\n#                                  <tr> 예약 상세정보 이게 중요한 예약 가능 정보임,\n#                                     <th rowspan =2> LAKES </th>  코스 정보 및 해당 코스(LAKES) 에 몇개 예약(rowspn)이 가능한지 숫자 나옴\n#                                     <td> 18:52 </td> 시간\n#                                     <td> 130,000 </td> 금액\n#                                     <td>\n#                                        <button conclick> 예약 선택 버튼 \"\"\"\n#\n# for d in wish_date:\n#     d = wish_date[2]\n#     wish_year = d[:4]\n#     wish_month = d[4:6]\n#     wish_day = d[6:8]\n#     try:\n#\n#         calendar = driver.find_element(By.XPATH, \"//div[@class='reservation_table calendar_table']/table/tbody\")\n#         date_selected = \"//tr/td/a[@class='open'  and @id =\" + \"'\" + d + \"']\"\n#         # temp_date = calendar.find_element(By.XPATH, \"//tr/td/a[@class='open'  and @id ='20211028']\")\n#         # calendar.find_element(By.XPATH, date_selected).text 에 예약이 가능하면 팀수가 나옴 없으면 예약 불가능하므로 예약 시도 cancel\n#         if calendar.find_element(By.XPATH, date_selected).text.find('팀') >= 0:\n#             calendar.find_element(By.XPATH, date_selected).click()  # 원하는 날짜에 해당하는 달력 check\n#             # calendar.find_element(By.XPATH, date_selected).text\n#\n#             reservation_time = driver.find_element(By.XPATH, \"//div[@class = 'reservation_table time_table']\")\n#             reservation_time_list = reservation_time.find_elements(By.XPATH, \"//table/tbody/tr/td/button\")\n#\n#             # s = reservation_time_list[0].get_attribute('onclick')\n#             # s = s.replace('showConfirm','').replace('(','').replace(')','').replace(\"'\",'').split(',')\n#\n#             # time table을 list로 만들자\n#             timeTable = pd.DataFrame()\n#             timeTable_columns = ['fulldate', 'day', 'hour', 'course_type', 'cousrse_name', 'price', 'unknown1',\n#                                  'unknown2', 'unknown3']\n#\n#             for i in range(len(reservation_time_list)):\n#                 s = reservation_time_list[i].get_attribute('onclick')\n#                 s = s.replace('showConfirm', '').replace('(', '').replace(')', '').replace(\"'\", '').split(',')\n#                 s = pd.DataFrame(data=[s])\n#                 timeTable = timeTable.append(s)\n#                 print(i, s)\n#\n#             timeTable.columns = timeTable_columns\n#             timeTable.reset_index(drop=True, inplace=True)\n#\n#             # 원하는 시간대 골라내기\n#             first_time = wish_hour[0].split('~')[0]\n#             end_time = wish_hour[0].split('~')[1]\n#             mask1 = (timeTable['hour'].str[0:2] >= first_time) & (timeTable['hour'].str[0:2] < end_time)  # 시간대 filter\n#             timeTable_filterd = timeTable.loc[mask1, :]\n#\n#             timeTable_sorted = timeTable_filterd.sort_values('hour')\n#             timeTable_sorted.reset_index(inplace=True)\n#\n#             if hour_option == 'first':\n#                 index_no = timeTable_sorted['index'].iloc[0]\n#             elif hour_option == 'mid':\n#                 index_no = timeTable_sorted['index'].iloc[round(len(timeTable_sorted) / 2)]\n#             elif hour_option == 'last':\n#                 index_no = timeTable_sorted['index'].iloc[-1]\n#\n#             # 골라낸 시간에 예약 버튼 누르기\n#\n#             # reservation_time_list[index_no].get_attribute('onclick')\n#             # reservation_time_list[index_no].click()\n#             #\n#             # reservation_time_list[index_no].get_attribute('onclick')\n#             driver.execute_script(\"arguments[0].click();\", reservation_time_list[index_no])\n#\n#             # 예약 확인 pop up\n#             # reserve_text = driver.find_element(By.XPATH,\n#             #                     \"//div[@id='confirmModal']/div[@class='modal_content']/div[@class='confirm_modal']/div[@class='form_btns']/button\").text\n#             # print(reserve_text)\n#             driver.find_element(By.XPATH,\n#                                 \"//div[@id='confirmModal']/div[@class='modal_content']/div[@class='confirm_modal']/div[@class='form_btns']/button\").click()\n#             # 이렇게 하면 바로 예약 됨\n#\n#         elif calendar.find_element(By.XPATH, date_selected).text.find('팀') == -1:  # 예약일이 없으면 바로 빠져 나와서 처리 속도를 높여줌\n#             print('There is no book', d)\n#             break\n#         else:\n#             print('Check your input condition!')\n#     except:\n#         print('There is no book', d)\n#\n# driver.close()\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/reservation_golf_for_macmini.py b/reservation_golf_for_macmini.py
--- a/reservation_golf_for_macmini.py	(revision da02644ed341b2e4fdba38daa852966a0a990c95)
+++ b/reservation_golf_for_macmini.py	(date 1644315028569)
@@ -496,10 +496,7 @@
         telegram_message(content='Please, check your reserve_type', content_type='text', description='description')
 
     able_ls = []
-    try:
-        driver = driverAct(url,osopt)
-    except:
-        telegram_message('Please check your chrom driver version or path.')
+    driver = driverAct(url,osopt)
     driver.get(loginpage)
     # if reserve_cnt is True ,then reservation don't stop
     # if reserve_cnt is False ,then reservation 1 time and stop
